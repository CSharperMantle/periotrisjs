{"version":3,"file":"component---src-pages-game-tsx-5abe35f78f7e74f36451.js","mappings":"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","sources":["webpack://periotrisjs/./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/debounce.js","webpack://periotrisjs/./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/now.js","webpack://periotrisjs/./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/throttle.js","webpack://periotrisjs/./src/PageID.ts","webpack://periotrisjs/./.yarn/cache/@use-gesture-core-npm-10.2.27-77f867575b-3cc29b93e2.zip/node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js","webpack://periotrisjs/./.yarn/cache/@use-gesture-core-npm-10.2.27-77f867575b-3cc29b93e2.zip/node_modules/@use-gesture/core/dist/actions-76b8683e.esm.js","webpack://periotrisjs/./.yarn/cache/@use-gesture-core-npm-10.2.27-77f867575b-3cc29b93e2.zip/node_modules/@use-gesture/core/dist/use-gesture-core.esm.js","webpack://periotrisjs/./.yarn/__virtual__/@use-gesture-react-virtual-f8a63e7bcb/0/cache/@use-gesture-react-npm-10.2.27-894aca6f40-745c835483.zip/node_modules/@use-gesture/react/dist/use-gesture-react.esm.js","webpack://periotrisjs/./src/pages/game.tsx"],"sourcesContent":["var isObject = require('./isObject'),\n    now = require('./now'),\n    toNumber = require('./toNumber');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n","var root = require('./_root');\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n","var debounce = require('./debounce'),\n    isObject = require('./isObject');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nmodule.exports = throttle;\n","/*\n * Copyright (C) 2021-present Rong \"Mantle\" Bao\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see https://www.gnu.org/licenses/ .\n */\n\nexport const enum PageID {\n  PAGE_HOME,\n  PAGE_GAME,\n  PAGE_AUTOPLAY,\n  PAGE_SETTINGS,\n  PAGE_ABOUT,\n}\n","function clamp(v, min, max) {\n  return Math.max(min, Math.min(v, max));\n}\nconst V = {\n  toVector(v, fallback) {\n    if (v === undefined) v = fallback;\n    return Array.isArray(v) ? v : [v, v];\n  },\n  add(v1, v2) {\n    return [v1[0] + v2[0], v1[1] + v2[1]];\n  },\n  sub(v1, v2) {\n    return [v1[0] - v2[0], v1[1] - v2[1]];\n  },\n  addTo(v1, v2) {\n    v1[0] += v2[0];\n    v1[1] += v2[1];\n  },\n  subTo(v1, v2) {\n    v1[0] -= v2[0];\n    v1[1] -= v2[1];\n  }\n};\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\nfunction rubberbandIfOutOfBounds(position, min, max, constant = 0.15) {\n  if (constant === 0) return clamp(position, min, max);\n  if (position < min) return -rubberband(min - position, max - min, constant) + min;\n  if (position > max) return +rubberband(position - max, max - min, constant) + max;\n  return position;\n}\nfunction computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {\n  const [[X0, X1], [Y0, Y1]] = bounds;\n  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];\n}\n\nexport { V, computeRubberband as c, rubberbandIfOutOfBounds as r };\n","import { V, c as computeRubberband } from './maths-0ab39ae9.esm.js';\n\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\n\nconst EVENT_TYPE_MAP = {\n  pointer: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  mouse: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  touch: {\n    start: 'start',\n    change: 'move',\n    end: 'end'\n  },\n  gesture: {\n    start: 'start',\n    change: 'change',\n    end: 'end'\n  }\n};\nfunction capitalize(string) {\n  if (!string) return '';\n  return string[0].toUpperCase() + string.slice(1);\n}\nconst actionsWithoutCaptureSupported = ['enter', 'leave'];\nfunction hasCapture(capture = false, actionKey) {\n  return capture && !actionsWithoutCaptureSupported.includes(actionKey);\n}\nfunction toHandlerProp(device, action = '', capture = false) {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return 'on' + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? 'Capture' : '');\n}\nconst pointerCaptureEvents = ['gotpointercapture', 'lostpointercapture'];\nfunction parseProp(prop) {\n  let eventKey = prop.substring(2).toLowerCase();\n  const passive = !!~eventKey.indexOf('passive');\n  if (passive) eventKey = eventKey.replace('passive', '');\n  const captureKey = pointerCaptureEvents.includes(eventKey) ? 'capturecapture' : 'capture';\n  const capture = !!~eventKey.indexOf(captureKey);\n  if (capture) eventKey = eventKey.replace('capture', '');\n  return {\n    device: eventKey,\n    capture,\n    passive\n  };\n}\nfunction toDomEventType(device, action = '') {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return device + actionKey;\n}\nfunction isTouch(event) {\n  return 'touches' in event;\n}\nfunction getPointerType(event) {\n  if (isTouch(event)) return 'touch';\n  if ('pointerType' in event) return event.pointerType;\n  return 'mouse';\n}\nfunction getCurrentTargetTouchList(event) {\n  return Array.from(event.touches).filter(e => {\n    var _event$currentTarget, _event$currentTarget$;\n    return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));\n  });\n}\nfunction getTouchList(event) {\n  return event.type === 'touchend' || event.type === 'touchcancel' ? event.changedTouches : event.targetTouches;\n}\nfunction getValueEvent(event) {\n  return isTouch(event) ? getTouchList(event)[0] : event;\n}\nfunction distanceAngle(P1, P2) {\n  try {\n    const dx = P2.clientX - P1.clientX;\n    const dy = P2.clientY - P1.clientY;\n    const cx = (P2.clientX + P1.clientX) / 2;\n    const cy = (P2.clientY + P1.clientY) / 2;\n    const distance = Math.hypot(dx, dy);\n    const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;\n    const origin = [cx, cy];\n    return {\n      angle,\n      distance,\n      origin\n    };\n  } catch (_unused) {}\n  return null;\n}\nfunction touchIds(event) {\n  return getCurrentTargetTouchList(event).map(touch => touch.identifier);\n}\nfunction touchDistanceAngle(event, ids) {\n  const [P1, P2] = Array.from(event.touches).filter(touch => ids.includes(touch.identifier));\n  return distanceAngle(P1, P2);\n}\nfunction pointerId(event) {\n  const valueEvent = getValueEvent(event);\n  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;\n}\nfunction pointerValues(event) {\n  const valueEvent = getValueEvent(event);\n  return [valueEvent.clientX, valueEvent.clientY];\n}\nconst LINE_HEIGHT = 40;\nconst PAGE_HEIGHT = 800;\nfunction wheelValues(event) {\n  let {\n    deltaX,\n    deltaY,\n    deltaMode\n  } = event;\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT;\n    deltaY *= LINE_HEIGHT;\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT;\n    deltaY *= PAGE_HEIGHT;\n  }\n  return [deltaX, deltaY];\n}\nfunction scrollValues(event) {\n  var _ref, _ref2;\n  const {\n    scrollX,\n    scrollY,\n    scrollLeft,\n    scrollTop\n  } = event.currentTarget;\n  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];\n}\nfunction getEventDetails(event) {\n  const payload = {};\n  if ('buttons' in event) payload.buttons = event.buttons;\n  if ('shiftKey' in event) {\n    const {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    } = event;\n    Object.assign(payload, {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    });\n  }\n  return payload;\n}\n\nfunction call(v, ...args) {\n  if (typeof v === 'function') {\n    return v(...args);\n  } else {\n    return v;\n  }\n}\nfunction noop() {}\nfunction chain(...fns) {\n  if (fns.length === 0) return noop;\n  if (fns.length === 1) return fns[0];\n  return function () {\n    let result;\n    for (const fn of fns) {\n      result = fn.apply(this, arguments) || result;\n    }\n    return result;\n  };\n}\nfunction assignDefault(value, fallback) {\n  return Object.assign({}, fallback, value || {});\n}\n\nconst BEFORE_LAST_KINEMATICS_DELAY = 32;\nclass Engine {\n  constructor(ctrl, args, key) {\n    this.ctrl = ctrl;\n    this.args = args;\n    this.key = key;\n    if (!this.state) {\n      this.state = {};\n      this.computeValues([0, 0]);\n      this.computeInitial();\n      if (this.init) this.init();\n      this.reset();\n    }\n  }\n  get state() {\n    return this.ctrl.state[this.key];\n  }\n  set state(state) {\n    this.ctrl.state[this.key] = state;\n  }\n  get shared() {\n    return this.ctrl.state.shared;\n  }\n  get eventStore() {\n    return this.ctrl.gestureEventStores[this.key];\n  }\n  get timeoutStore() {\n    return this.ctrl.gestureTimeoutStores[this.key];\n  }\n  get config() {\n    return this.ctrl.config[this.key];\n  }\n  get sharedConfig() {\n    return this.ctrl.config.shared;\n  }\n  get handler() {\n    return this.ctrl.handlers[this.key];\n  }\n  reset() {\n    const {\n      state,\n      shared,\n      ingKey,\n      args\n    } = this;\n    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;\n    state._step = [false, false];\n    state.intentional = false;\n    state._movement = [0, 0];\n    state._distance = [0, 0];\n    state._direction = [0, 0];\n    state._delta = [0, 0];\n    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];\n    state.args = args;\n    state.axis = undefined;\n    state.memo = undefined;\n    state.elapsedTime = state.timeDelta = 0;\n    state.direction = [0, 0];\n    state.distance = [0, 0];\n    state.overflow = [0, 0];\n    state._movementBound = [false, false];\n    state.velocity = [0, 0];\n    state.movement = [0, 0];\n    state.delta = [0, 0];\n    state.timeStamp = 0;\n  }\n  start(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state._active) {\n      this.reset();\n      this.computeInitial();\n      state._active = true;\n      state.target = event.target;\n      state.currentTarget = event.currentTarget;\n      state.lastOffset = config.from ? call(config.from, state) : state.offset;\n      state.offset = state.lastOffset;\n      state.startTime = state.timeStamp = event.timeStamp;\n    }\n  }\n  computeValues(values) {\n    const state = this.state;\n    state._values = values;\n    state.values = this.config.transform(values);\n  }\n  computeInitial() {\n    const state = this.state;\n    state._initial = state._values;\n    state.initial = state.values;\n  }\n  compute(event) {\n    const {\n      state,\n      config,\n      shared\n    } = this;\n    state.args = this.args;\n    let dt = 0;\n    if (event) {\n      state.event = event;\n      if (config.preventDefault && event.cancelable) state.event.preventDefault();\n      state.type = event.type;\n      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;\n      shared.locked = !!document.pointerLockElement;\n      Object.assign(shared, getEventDetails(event));\n      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;\n      dt = event.timeStamp - state.timeStamp;\n      state.timeStamp = event.timeStamp;\n      state.elapsedTime = state.timeStamp - state.startTime;\n    }\n    if (state._active) {\n      const _absoluteDelta = state._delta.map(Math.abs);\n      V.addTo(state._distance, _absoluteDelta);\n    }\n    if (this.axisIntent) this.axisIntent(event);\n    const [_m0, _m1] = state._movement;\n    const [t0, t1] = config.threshold;\n    const {\n      _step,\n      values\n    } = state;\n    if (config.hasCustomTransform) {\n      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];\n      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];\n    } else {\n      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;\n      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;\n    }\n    state.intentional = _step[0] !== false || _step[1] !== false;\n    if (!state.intentional) return;\n    const movement = [0, 0];\n    if (config.hasCustomTransform) {\n      const [v0, v1] = values;\n      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;\n    } else {\n      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;\n    }\n    if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);\n    const previousOffset = state.offset;\n    const gestureIsActive = state._active && !state._blocked || state.active;\n    if (gestureIsActive) {\n      state.first = state._active && !state.active;\n      state.last = !state._active && state.active;\n      state.active = shared[this.ingKey] = state._active;\n      if (event) {\n        if (state.first) {\n          if ('bounds' in config) state._bounds = call(config.bounds, state);\n          if (this.setup) this.setup();\n        }\n        state.movement = movement;\n        this.computeOffset();\n      }\n    }\n    const [ox, oy] = state.offset;\n    const [[x0, x1], [y0, y1]] = state._bounds;\n    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];\n    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;\n    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;\n    const rubberband = state._active ? config.rubberband || [0, 0] : [0, 0];\n    state.offset = computeRubberband(state._bounds, state.offset, rubberband);\n    state.delta = V.sub(state.offset, previousOffset);\n    this.computeMovement();\n    if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {\n      state.delta = V.sub(state.offset, previousOffset);\n      const absoluteDelta = state.delta.map(Math.abs);\n      V.addTo(state.distance, absoluteDelta);\n      state.direction = state.delta.map(Math.sign);\n      state._direction = state._delta.map(Math.sign);\n      if (!state.first && dt > 0) {\n        state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];\n        state.timeDelta = dt;\n      }\n    }\n  }\n  emit() {\n    const state = this.state;\n    const shared = this.shared;\n    const config = this.config;\n    if (!state._active) this.clean();\n    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;\n    const memo = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {\n      [this.aliasKey]: state.values\n    }));\n    if (memo !== undefined) state.memo = memo;\n  }\n  clean() {\n    this.eventStore.clean();\n    this.timeoutStore.clean();\n  }\n}\n\nfunction selectAxis([dx, dy], threshold) {\n  const absDx = Math.abs(dx);\n  const absDy = Math.abs(dy);\n  if (absDx > absDy && absDx > threshold) {\n    return 'x';\n  }\n  if (absDy > absDx && absDy > threshold) {\n    return 'y';\n  }\n  return undefined;\n}\nclass CoordinatesEngine extends Engine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"aliasKey\", 'xy');\n  }\n  reset() {\n    super.reset();\n    this.state.axis = undefined;\n  }\n  init() {\n    this.state.offset = [0, 0];\n    this.state.lastOffset = [0, 0];\n  }\n  computeOffset() {\n    this.state.offset = V.add(this.state.lastOffset, this.state.movement);\n  }\n  computeMovement() {\n    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);\n  }\n  axisIntent(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state.axis && event) {\n      const threshold = typeof config.axisThreshold === 'object' ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;\n      state.axis = selectAxis(state._movement, threshold);\n    }\n    state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;\n  }\n  restrictToAxis(v) {\n    if (this.config.axis || this.config.lockDirection) {\n      switch (this.state.axis) {\n        case 'x':\n          v[1] = 0;\n          break;\n        case 'y':\n          v[0] = 0;\n          break;\n      }\n    }\n  }\n}\n\nconst identity = v => v;\nconst DEFAULT_RUBBERBAND = 0.15;\nconst commonConfigResolver = {\n  enabled(value = true) {\n    return value;\n  },\n  eventOptions(value, _k, config) {\n    return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value);\n  },\n  preventDefault(value = false) {\n    return value;\n  },\n  triggerAllEvents(value = false) {\n    return value;\n  },\n  rubberband(value = 0) {\n    switch (value) {\n      case true:\n        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];\n      case false:\n        return [0, 0];\n      default:\n        return V.toVector(value);\n    }\n  },\n  from(value) {\n    if (typeof value === 'function') return value;\n    if (value != null) return V.toVector(value);\n  },\n  transform(value, _k, config) {\n    const transform = value || config.shared.transform;\n    this.hasCustomTransform = !!transform;\n    if (process.env.NODE_ENV === 'development') {\n      const originalTransform = transform || identity;\n      return v => {\n        const r = originalTransform(v);\n        if (!isFinite(r[0]) || !isFinite(r[1])) {\n          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r[0]},${[1]}]`);\n        }\n        return r;\n      };\n    }\n    return transform || identity;\n  },\n  threshold(value) {\n    return V.toVector(value, 0);\n  }\n};\nif (process.env.NODE_ENV === 'development') {\n  Object.assign(commonConfigResolver, {\n    domTarget(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n      }\n      return NaN;\n    },\n    lockDirection(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`lockDirection\\` option has been merged with \\`axis\\`. Use it as in \\`{ axis: 'lock' }\\``);\n      }\n      return NaN;\n    },\n    initial(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`initial\\` option has been renamed to \\`from\\`.`);\n      }\n      return NaN;\n    }\n  });\n}\n\nconst DEFAULT_AXIS_THRESHOLD = 0;\nconst coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  axis(_v, _k, {\n    axis\n  }) {\n    this.lockDirection = axis === 'lock';\n    if (!this.lockDirection) return axis;\n  },\n  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {\n    return value;\n  },\n  bounds(value = {}) {\n    if (typeof value === 'function') {\n      return state => coordinatesConfigResolver.bounds(value(state));\n    }\n    if ('current' in value) {\n      return () => value.current;\n    }\n    if (typeof HTMLElement === 'function' && value instanceof HTMLElement) {\n      return value;\n    }\n    const {\n      left = -Infinity,\n      right = Infinity,\n      top = -Infinity,\n      bottom = Infinity\n    } = value;\n    return [[left, right], [top, bottom]];\n  }\n});\n\nconst KEYS_DELTA_MAP = {\n  ArrowRight: (displacement, factor = 1) => [displacement * factor, 0],\n  ArrowLeft: (displacement, factor = 1) => [-1 * displacement * factor, 0],\n  ArrowUp: (displacement, factor = 1) => [0, -1 * displacement * factor],\n  ArrowDown: (displacement, factor = 1) => [0, displacement * factor]\n};\nclass DragEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'dragging');\n  }\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._pointerId = undefined;\n    state._pointerActive = false;\n    state._keyboardActive = false;\n    state._preventScroll = false;\n    state._delayed = false;\n    state.swipe = [0, 0];\n    state.tap = false;\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n  }\n  setup() {\n    const state = this.state;\n    if (state._bounds instanceof HTMLElement) {\n      const boundRect = state._bounds.getBoundingClientRect();\n      const targetRect = state.currentTarget.getBoundingClientRect();\n      const _bounds = {\n        left: boundRect.left - targetRect.left + state.offset[0],\n        right: boundRect.right - targetRect.right + state.offset[0],\n        top: boundRect.top - targetRect.top + state.offset[1],\n        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]\n      };\n      state._bounds = coordinatesConfigResolver.bounds(_bounds);\n    }\n  }\n  cancel() {\n    const state = this.state;\n    if (state.canceled) return;\n    state.canceled = true;\n    state._active = false;\n    setTimeout(() => {\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n  setActive() {\n    this.state._active = this.state._pointerActive || this.state._keyboardActive;\n  }\n  clean() {\n    this.pointerClean();\n    this.state._pointerActive = false;\n    this.state._keyboardActive = false;\n    super.clean();\n  }\n  pointerDown(event) {\n    const config = this.config;\n    const state = this.state;\n    if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons)) return;\n    const ctrlIds = this.ctrl.setEventIds(event);\n    if (config.pointerCapture) {\n      event.target.setPointerCapture(event.pointerId);\n    }\n    if (ctrlIds && ctrlIds.size > 1 && state._pointerActive) return;\n    this.start(event);\n    this.setupPointer(event);\n    state._pointerId = pointerId(event);\n    state._pointerActive = true;\n    this.computeValues(pointerValues(event));\n    this.computeInitial();\n    if (config.preventScrollAxis && getPointerType(event) !== 'mouse') {\n      state._active = false;\n      this.setupScrollPrevention(event);\n    } else if (config.delay > 0) {\n      this.setupDelayTrigger(event);\n      if (config.triggerAllEvents) {\n        this.compute(event);\n        this.emit();\n      }\n    } else {\n      this.startPointerDrag(event);\n    }\n  }\n  startPointerDrag(event) {\n    const state = this.state;\n    state._active = true;\n    state._preventScroll = true;\n    state._delayed = false;\n    this.compute(event);\n    this.emit();\n  }\n  pointerMove(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state._pointerActive) return;\n    const id = pointerId(event);\n    if (state._pointerId !== undefined && id !== state._pointerId) return;\n    const _values = pointerValues(event);\n    if (document.pointerLockElement === event.target) {\n      state._delta = [event.movementX, event.movementY];\n    } else {\n      state._delta = V.sub(_values, state._values);\n      this.computeValues(_values);\n    }\n    V.addTo(state._movement, state._delta);\n    this.compute(event);\n    if (state._delayed && state.intentional) {\n      this.timeoutStore.remove('dragDelay');\n      state.active = false;\n      this.startPointerDrag(event);\n      return;\n    }\n    if (config.preventScrollAxis && !state._preventScroll) {\n      if (state.axis) {\n        if (state.axis === config.preventScrollAxis || config.preventScrollAxis === 'xy') {\n          state._active = false;\n          this.clean();\n          return;\n        } else {\n          this.timeoutStore.remove('startPointerDrag');\n          this.startPointerDrag(event);\n          return;\n        }\n      } else {\n        return;\n      }\n    }\n    this.emit();\n  }\n  pointerUp(event) {\n    this.ctrl.setEventIds(event);\n    try {\n      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {\n        ;\n        event.target.releasePointerCapture(event.pointerId);\n      }\n    } catch (_unused) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \\`@react-three/fiber\\`. \\n\\nPlease upgrade to the latest version.`);\n      }\n    }\n    const state = this.state;\n    const config = this.config;\n    if (!state._active || !state._pointerActive) return;\n    const id = pointerId(event);\n    if (state._pointerId !== undefined && id !== state._pointerId) return;\n    this.state._pointerActive = false;\n    this.setActive();\n    this.compute(event);\n    const [dx, dy] = state._distance;\n    state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;\n    if (state.tap && config.filterTaps) {\n      state._force = true;\n    } else {\n      const [_dx, _dy] = state._delta;\n      const [_mx, _my] = state._movement;\n      const [svx, svy] = config.swipe.velocity;\n      const [sx, sy] = config.swipe.distance;\n      const sdt = config.swipe.duration;\n      if (state.elapsedTime < sdt) {\n        const _vx = Math.abs(_dx / state.timeDelta);\n        const _vy = Math.abs(_dy / state.timeDelta);\n        if (_vx > svx && Math.abs(_mx) > sx) state.swipe[0] = Math.sign(_dx);\n        if (_vy > svy && Math.abs(_my) > sy) state.swipe[1] = Math.sign(_dy);\n      }\n    }\n    this.emit();\n  }\n  pointerClick(event) {\n    if (!this.state.tap && event.detail > 0) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n  setupPointer(event) {\n    const config = this.config;\n    const device = config.device;\n    if (process.env.NODE_ENV === 'development') {\n      try {\n        if (device === 'pointer' && config.preventScrollDelay === undefined) {\n          const currentTarget = 'uv' in event ? event.sourceEvent.currentTarget : event.currentTarget;\n          const style = window.getComputedStyle(currentTarget);\n          if (style.touchAction === 'auto') {\n            console.warn(`[@use-gesture]: The drag target has its \\`touch-action\\` style property set to \\`auto\\`. It is recommended to add \\`touch-action: 'none'\\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\\n\\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);\n          }\n        }\n      } catch (_unused2) {}\n    }\n    if (config.pointerLock) {\n      event.currentTarget.requestPointerLock();\n    }\n    if (!config.pointerCapture) {\n      this.eventStore.add(this.sharedConfig.window, device, 'change', this.pointerMove.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, 'end', this.pointerUp.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, 'cancel', this.pointerUp.bind(this));\n    }\n  }\n  pointerClean() {\n    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {\n      document.exitPointerLock();\n    }\n  }\n  preventScroll(event) {\n    if (this.state._preventScroll && event.cancelable) {\n      event.preventDefault();\n    }\n  }\n  setupScrollPrevention(event) {\n    this.state._preventScroll = false;\n    persistEvent(event);\n    const remove = this.eventStore.add(this.sharedConfig.window, 'touch', 'change', this.preventScroll.bind(this), {\n      passive: false\n    });\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'end', remove);\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'cancel', remove);\n    this.timeoutStore.add('startPointerDrag', this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);\n  }\n  setupDelayTrigger(event) {\n    this.state._delayed = true;\n    this.timeoutStore.add('dragDelay', () => {\n      this.state._step = [0, 0];\n      this.startPointerDrag(event);\n    }, this.config.delay);\n  }\n  keyDown(event) {\n    const deltaFn = KEYS_DELTA_MAP[event.key];\n    if (deltaFn) {\n      const state = this.state;\n      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;\n      this.start(event);\n      state._delta = deltaFn(this.config.keyboardDisplacement, factor);\n      state._keyboardActive = true;\n      V.addTo(state._movement, state._delta);\n      this.compute(event);\n      this.emit();\n    }\n  }\n  keyUp(event) {\n    if (!(event.key in KEYS_DELTA_MAP)) return;\n    this.state._keyboardActive = false;\n    this.setActive();\n    this.compute(event);\n    this.emit();\n  }\n  bind(bindFunction) {\n    const device = this.config.device;\n    bindFunction(device, 'start', this.pointerDown.bind(this));\n    if (this.config.pointerCapture) {\n      bindFunction(device, 'change', this.pointerMove.bind(this));\n      bindFunction(device, 'end', this.pointerUp.bind(this));\n      bindFunction(device, 'cancel', this.pointerUp.bind(this));\n      bindFunction('lostPointerCapture', '', this.pointerUp.bind(this));\n    }\n    if (this.config.keys) {\n      bindFunction('key', 'down', this.keyDown.bind(this));\n      bindFunction('key', 'up', this.keyUp.bind(this));\n    }\n    if (this.config.filterTaps) {\n      bindFunction('click', '', this.pointerClick.bind(this), {\n        capture: true,\n        passive: false\n      });\n    }\n  }\n}\nfunction persistEvent(event) {\n  'persist' in event && typeof event.persist === 'function' && event.persist();\n}\n\nconst isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement;\nfunction supportsTouchEvents() {\n  return isBrowser && 'ontouchstart' in window;\n}\nfunction isTouchScreen() {\n  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;\n}\nfunction supportsPointerEvents() {\n  return isBrowser && 'onpointerdown' in window;\n}\nfunction supportsPointerLock() {\n  return isBrowser && 'exitPointerLock' in window.document;\n}\nfunction supportsGestureEvents() {\n  try {\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\nconst SUPPORT = {\n  isBrowser,\n  gesture: supportsGestureEvents(),\n  touch: isTouchScreen(),\n  touchscreen: isTouchScreen(),\n  pointer: supportsPointerEvents(),\n  pointerLock: supportsPointerLock()\n};\n\nconst DEFAULT_PREVENT_SCROLL_DELAY = 250;\nconst DEFAULT_DRAG_DELAY = 180;\nconst DEFAULT_SWIPE_VELOCITY = 0.5;\nconst DEFAULT_SWIPE_DISTANCE = 50;\nconst DEFAULT_SWIPE_DURATION = 250;\nconst DEFAULT_KEYBOARD_DISPLACEMENT = 10;\nconst DEFAULT_DRAG_AXIS_THRESHOLD = {\n  mouse: 0,\n  touch: 0,\n  pen: 8\n};\nconst dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  device(_v, _k, {\n    pointer: {\n      touch = false,\n      lock = false,\n      mouse = false\n    } = {}\n  }) {\n    this.pointerLock = lock && SUPPORT.pointerLock;\n    if (SUPPORT.touch && touch) return 'touch';\n    if (this.pointerLock) return 'mouse';\n    if (SUPPORT.pointer && !mouse) return 'pointer';\n    if (SUPPORT.touch) return 'touch';\n    return 'mouse';\n  },\n  preventScrollAxis(value, _k, {\n    preventScroll\n  }) {\n    this.preventScrollDelay = typeof preventScroll === 'number' ? preventScroll : preventScroll || preventScroll === undefined && value ? DEFAULT_PREVENT_SCROLL_DELAY : undefined;\n    if (!SUPPORT.touchscreen || preventScroll === false) return undefined;\n    return value ? value : preventScroll !== undefined ? 'y' : undefined;\n  },\n  pointerCapture(_v, _k, {\n    pointer: {\n      capture = true,\n      buttons = 1,\n      keys = true\n    } = {}\n  }) {\n    this.pointerButtons = buttons;\n    this.keys = keys;\n    return !this.pointerLock && this.device === 'pointer' && capture;\n  },\n  threshold(value, _k, {\n    filterTaps = false,\n    tapsThreshold = 3,\n    axis = undefined\n  }) {\n    const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);\n    this.filterTaps = filterTaps;\n    this.tapsThreshold = tapsThreshold;\n    return threshold;\n  },\n  swipe({\n    velocity = DEFAULT_SWIPE_VELOCITY,\n    distance = DEFAULT_SWIPE_DISTANCE,\n    duration = DEFAULT_SWIPE_DURATION\n  } = {}) {\n    return {\n      velocity: this.transform(V.toVector(velocity)),\n      distance: this.transform(V.toVector(distance)),\n      duration\n    };\n  },\n  delay(value = 0) {\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY;\n      case false:\n        return 0;\n      default:\n        return value;\n    }\n  },\n  axisThreshold(value) {\n    if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD;\n    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);\n  },\n  keyboardDisplacement(value = DEFAULT_KEYBOARD_DISPLACEMENT) {\n    return value;\n  }\n});\nif (process.env.NODE_ENV === 'development') {\n  Object.assign(dragConfigResolver, {\n    useTouch(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`useTouch\\` option has been renamed to \\`pointer.touch\\`. Use it as in \\`{ pointer: { touch: true } }\\`.`);\n      }\n      return NaN;\n    },\n    experimental_preventWindowScrollY(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`experimental_preventWindowScrollY\\` option has been renamed to \\`preventScroll\\`.`);\n      }\n      return NaN;\n    },\n    swipeVelocity(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeVelocity\\` option has been renamed to \\`swipe.velocity\\`. Use it as in \\`{ swipe: { velocity: 0.5 } }\\`.`);\n      }\n      return NaN;\n    },\n    swipeDistance(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeDistance\\` option has been renamed to \\`swipe.distance\\`. Use it as in \\`{ swipe: { distance: 50 } }\\`.`);\n      }\n      return NaN;\n    },\n    swipeDuration(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeDuration\\` option has been renamed to \\`swipe.duration\\`. Use it as in \\`{ swipe: { duration: 250 } }\\`.`);\n      }\n      return NaN;\n    }\n  });\n}\n\nfunction clampStateInternalMovementToBounds(state) {\n  const [ox, oy] = state.overflow;\n  const [dx, dy] = state._delta;\n  const [dirx, diry] = state._direction;\n  if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {\n    state._movement[0] = state._movementBound[0];\n  }\n  if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {\n    state._movement[1] = state._movementBound[1];\n  }\n}\n\nconst SCALE_ANGLE_RATIO_INTENT_DEG = 30;\nconst PINCH_WHEEL_RATIO = 100;\nclass PinchEngine extends Engine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'pinching');\n    _defineProperty(this, \"aliasKey\", 'da');\n  }\n  init() {\n    this.state.offset = [1, 0];\n    this.state.lastOffset = [1, 0];\n    this.state._pointerEvents = new Map();\n  }\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._touchIds = [];\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n    state.turns = 0;\n  }\n  computeOffset() {\n    const {\n      type,\n      movement,\n      lastOffset\n    } = this.state;\n    if (type === 'wheel') {\n      this.state.offset = V.add(movement, lastOffset);\n    } else {\n      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];\n    }\n  }\n  computeMovement() {\n    const {\n      offset,\n      lastOffset\n    } = this.state;\n    this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];\n  }\n  axisIntent() {\n    const state = this.state;\n    const [_m0, _m1] = state._movement;\n    if (!state.axis) {\n      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);\n      if (axisMovementDifference < 0) state.axis = 'angle';else if (axisMovementDifference > 0) state.axis = 'scale';\n    }\n  }\n  restrictToAxis(v) {\n    if (this.config.lockDirection) {\n      if (this.state.axis === 'scale') v[1] = 0;else if (this.state.axis === 'angle') v[0] = 0;\n    }\n  }\n  cancel() {\n    const state = this.state;\n    if (state.canceled) return;\n    setTimeout(() => {\n      state.canceled = true;\n      state._active = false;\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n  touchStart(event) {\n    this.ctrl.setEventIds(event);\n    const state = this.state;\n    const ctrlTouchIds = this.ctrl.touchIds;\n    if (state._active) {\n      if (state._touchIds.every(id => ctrlTouchIds.has(id))) return;\n    }\n    if (ctrlTouchIds.size < 2) return;\n    this.start(event);\n    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);\n    const payload = touchDistanceAngle(event, state._touchIds);\n    if (!payload) return;\n    this.pinchStart(event, payload);\n  }\n  pointerStart(event) {\n    if (event.buttons != null && event.buttons % 2 !== 1) return;\n    this.ctrl.setEventIds(event);\n    event.target.setPointerCapture(event.pointerId);\n    const state = this.state;\n    const _pointerEvents = state._pointerEvents;\n    const ctrlPointerIds = this.ctrl.pointerIds;\n    if (state._active) {\n      if (Array.from(_pointerEvents.keys()).every(id => ctrlPointerIds.has(id))) return;\n    }\n    if (_pointerEvents.size < 2) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n    if (state._pointerEvents.size < 2) return;\n    this.start(event);\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    if (!payload) return;\n    this.pinchStart(event, payload);\n  }\n  pinchStart(event, payload) {\n    const state = this.state;\n    state.origin = payload.origin;\n    this.computeValues([payload.distance, payload.angle]);\n    this.computeInitial();\n    this.compute(event);\n    this.emit();\n  }\n  touchMove(event) {\n    if (!this.state._active) return;\n    const payload = touchDistanceAngle(event, this.state._touchIds);\n    if (!payload) return;\n    this.pinchMove(event, payload);\n  }\n  pointerMove(event) {\n    const _pointerEvents = this.state._pointerEvents;\n    if (_pointerEvents.has(event.pointerId)) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n    if (!this.state._active) return;\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    if (!payload) return;\n    this.pinchMove(event, payload);\n  }\n  pinchMove(event, payload) {\n    const state = this.state;\n    const prev_a = state._values[1];\n    const delta_a = payload.angle - prev_a;\n    let delta_turns = 0;\n    if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);\n    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);\n    state.origin = payload.origin;\n    state.turns = delta_turns;\n    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];\n    this.compute(event);\n    this.emit();\n  }\n  touchEnd(event) {\n    this.ctrl.setEventIds(event);\n    if (!this.state._active) return;\n    if (this.state._touchIds.some(id => !this.ctrl.touchIds.has(id))) {\n      this.state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n  pointerEnd(event) {\n    const state = this.state;\n    this.ctrl.setEventIds(event);\n    try {\n      event.target.releasePointerCapture(event.pointerId);\n    } catch (_unused) {}\n    if (state._pointerEvents.has(event.pointerId)) {\n      state._pointerEvents.delete(event.pointerId);\n    }\n    if (!state._active) return;\n    if (state._pointerEvents.size < 2) {\n      state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n  gestureStart(event) {\n    if (event.cancelable) event.preventDefault();\n    const state = this.state;\n    if (state._active) return;\n    this.start(event);\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n  gestureMove(event) {\n    if (event.cancelable) event.preventDefault();\n    if (!this.state._active) return;\n    const state = this.state;\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    const _previousMovement = state._movement;\n    state._movement = [event.scale - 1, event.rotation];\n    state._delta = V.sub(state._movement, _previousMovement);\n    this.compute(event);\n    this.emit();\n  }\n  gestureEnd(event) {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n  wheel(event) {\n    const modifierKey = this.config.modifierKey;\n    if (modifierKey && !event[modifierKey]) return;\n    if (!this.state._active) this.wheelStart(event);else this.wheelChange(event);\n    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n  }\n  wheelStart(event) {\n    this.start(event);\n    this.wheelChange(event);\n  }\n  wheelChange(event) {\n    const isR3f = ('uv' in event);\n    if (!isR3f) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      if (process.env.NODE_ENV === 'development' && !event.defaultPrevented) {\n        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \\`target\\` option.\\n\\nThis message will only appear in development mode.`);\n      }\n    }\n    const state = this.state;\n    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];\n    V.addTo(state._movement, state._delta);\n    clampStateInternalMovementToBounds(state);\n    this.state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n  wheelEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n  bind(bindFunction) {\n    const device = this.config.device;\n    if (!!device) {\n      bindFunction(device, 'start', this[device + 'Start'].bind(this));\n      bindFunction(device, 'change', this[device + 'Move'].bind(this));\n      bindFunction(device, 'end', this[device + 'End'].bind(this));\n      bindFunction(device, 'cancel', this[device + 'End'].bind(this));\n      bindFunction('lostPointerCapture', '', this[device + 'End'].bind(this));\n    }\n    if (this.config.pinchOnWheel) {\n      bindFunction('wheel', '', this.wheel.bind(this), {\n        passive: false\n      });\n    }\n  }\n}\n\nconst pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  device(_v, _k, {\n    shared,\n    pointer: {\n      touch = false\n    } = {}\n  }) {\n    const sharedConfig = shared;\n    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return 'gesture';\n    if (SUPPORT.touch && touch) return 'touch';\n    if (SUPPORT.touchscreen) {\n      if (SUPPORT.pointer) return 'pointer';\n      if (SUPPORT.touch) return 'touch';\n    }\n  },\n  bounds(_v, _k, {\n    scaleBounds = {},\n    angleBounds = {}\n  }) {\n    const _scaleBounds = state => {\n      const D = assignDefault(call(scaleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [D.min, D.max];\n    };\n    const _angleBounds = state => {\n      const A = assignDefault(call(angleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [A.min, A.max];\n    };\n    if (typeof scaleBounds !== 'function' && typeof angleBounds !== 'function') return [_scaleBounds(), _angleBounds()];\n    return state => [_scaleBounds(state), _angleBounds(state)];\n  },\n  threshold(value, _k, config) {\n    this.lockDirection = config.axis === 'lock';\n    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);\n    return threshold;\n  },\n  modifierKey(value) {\n    if (value === undefined) return 'ctrlKey';\n    return value;\n  },\n  pinchOnWheel(value = true) {\n    return value;\n  }\n});\n\nclass MoveEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'moving');\n  }\n  move(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    if (!this.state._active) this.moveStart(event);else this.moveChange(event);\n    this.timeoutStore.add('moveEnd', this.moveEnd.bind(this));\n  }\n  moveStart(event) {\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.computeInitial();\n    this.emit();\n  }\n  moveChange(event) {\n    if (!this.state._active) return;\n    const values = pointerValues(event);\n    const state = this.state;\n    state._delta = V.sub(values, state._values);\n    V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n  moveEnd(event) {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction('pointer', 'change', this.move.bind(this));\n    bindFunction('pointer', 'leave', this.moveEnd.bind(this));\n  }\n}\n\nconst moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\n\nclass ScrollEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'scrolling');\n  }\n  scroll(event) {\n    if (!this.state._active) this.start(event);\n    this.scrollChange(event);\n    this.timeoutStore.add('scrollEnd', this.scrollEnd.bind(this));\n  }\n  scrollChange(event) {\n    if (event.cancelable) event.preventDefault();\n    const state = this.state;\n    const values = scrollValues(event);\n    state._delta = V.sub(values, state._values);\n    V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n  scrollEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction('scroll', '', this.scroll.bind(this));\n  }\n}\n\nconst scrollConfigResolver = coordinatesConfigResolver;\n\nclass WheelEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'wheeling');\n  }\n  wheel(event) {\n    if (!this.state._active) this.start(event);\n    this.wheelChange(event);\n    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n  }\n  wheelChange(event) {\n    const state = this.state;\n    state._delta = wheelValues(event);\n    V.addTo(state._movement, state._delta);\n    clampStateInternalMovementToBounds(state);\n    this.compute(event);\n    this.emit();\n  }\n  wheelEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction('wheel', '', this.wheel.bind(this));\n  }\n}\n\nconst wheelConfigResolver = coordinatesConfigResolver;\n\nclass HoverEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'hovering');\n  }\n  enter(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.emit();\n  }\n  leave(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    const state = this.state;\n    if (!state._active) return;\n    state._active = false;\n    const values = pointerValues(event);\n    state._movement = state._delta = V.sub(values, state._values);\n    this.computeValues(values);\n    this.compute(event);\n    state.delta = state.movement;\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction('pointer', 'enter', this.enter.bind(this));\n    bindFunction('pointer', 'leave', this.leave.bind(this));\n  }\n}\n\nconst hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\n\nconst EngineMap = new Map();\nconst ConfigResolverMap = new Map();\nfunction registerAction(action) {\n  EngineMap.set(action.key, action.engine);\n  ConfigResolverMap.set(action.key, action.resolver);\n}\nconst dragAction = {\n  key: 'drag',\n  engine: DragEngine,\n  resolver: dragConfigResolver\n};\nconst hoverAction = {\n  key: 'hover',\n  engine: HoverEngine,\n  resolver: hoverConfigResolver\n};\nconst moveAction = {\n  key: 'move',\n  engine: MoveEngine,\n  resolver: moveConfigResolver\n};\nconst pinchAction = {\n  key: 'pinch',\n  engine: PinchEngine,\n  resolver: pinchConfigResolver\n};\nconst scrollAction = {\n  key: 'scroll',\n  engine: ScrollEngine,\n  resolver: scrollConfigResolver\n};\nconst wheelAction = {\n  key: 'wheel',\n  engine: WheelEngine,\n  resolver: wheelConfigResolver\n};\n\nexport { ConfigResolverMap as C, EngineMap as E, SUPPORT as S, _objectSpread2 as _, _defineProperty as a, touchIds as b, chain as c, toHandlerProp as d, dragAction as e, pinchAction as f, hoverAction as h, isTouch as i, moveAction as m, parseProp as p, registerAction as r, scrollAction as s, toDomEventType as t, wheelAction as w };\n","import { S as SUPPORT, C as ConfigResolverMap, _ as _objectSpread2, a as _defineProperty, t as toDomEventType, i as isTouch, b as touchIds, E as EngineMap, c as chain, p as parseProp, d as toHandlerProp } from './actions-76b8683e.esm.js';\nimport './maths-0ab39ae9.esm.js';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nconst sharedConfigResolver = {\n  target(value) {\n    if (value) {\n      return () => 'current' in value ? value.current : value;\n    }\n    return undefined;\n  },\n  enabled(value = true) {\n    return value;\n  },\n  window(value = SUPPORT.isBrowser ? window : undefined) {\n    return value;\n  },\n  eventOptions({\n    passive = true,\n    capture = false\n  } = {}) {\n    return {\n      passive,\n      capture\n    };\n  },\n  transform(value) {\n    return value;\n  }\n};\n\nconst _excluded = [\"target\", \"eventOptions\", \"window\", \"enabled\", \"transform\"];\nfunction resolveWith(config = {}, resolvers) {\n  const result = {};\n  for (const [key, resolver] of Object.entries(resolvers)) {\n    switch (typeof resolver) {\n      case 'function':\n        if (process.env.NODE_ENV === 'development') {\n          const r = resolver.call(result, config[key], key, config);\n          if (!Number.isNaN(r)) result[key] = r;\n        } else {\n          result[key] = resolver.call(result, config[key], key, config);\n        }\n        break;\n      case 'object':\n        result[key] = resolveWith(config[key], resolver);\n        break;\n      case 'boolean':\n        if (resolver) result[key] = config[key];\n        break;\n    }\n  }\n  return result;\n}\nfunction parse(newConfig, gestureKey, _config = {}) {\n  const _ref = newConfig,\n    {\n      target,\n      eventOptions,\n      window,\n      enabled,\n      transform\n    } = _ref,\n    rest = _objectWithoutProperties(_ref, _excluded);\n  _config.shared = resolveWith({\n    target,\n    eventOptions,\n    window,\n    enabled,\n    transform\n  }, sharedConfigResolver);\n  if (gestureKey) {\n    const resolver = ConfigResolverMap.get(gestureKey);\n    _config[gestureKey] = resolveWith(_objectSpread2({\n      shared: _config.shared\n    }, rest), resolver);\n  } else {\n    for (const key in rest) {\n      const resolver = ConfigResolverMap.get(key);\n      if (resolver) {\n        _config[key] = resolveWith(_objectSpread2({\n          shared: _config.shared\n        }, rest[key]), resolver);\n      } else if (process.env.NODE_ENV === 'development') {\n        if (!['drag', 'pinch', 'scroll', 'wheel', 'move', 'hover'].includes(key)) {\n          if (key === 'domTarget') {\n            throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n          }\n          console.warn(`[@use-gesture]: Unknown config key \\`${key}\\` was used. Please read the documentation for further information.`);\n        }\n      }\n    }\n  }\n  return _config;\n}\n\nclass EventStore {\n  constructor(ctrl, gestureKey) {\n    _defineProperty(this, \"_listeners\", new Set());\n    this._ctrl = ctrl;\n    this._gestureKey = gestureKey;\n  }\n  add(element, device, action, handler, options) {\n    const listeners = this._listeners;\n    const type = toDomEventType(device, action);\n    const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};\n    const eventOptions = _objectSpread2(_objectSpread2({}, _options), options);\n    element.addEventListener(type, handler, eventOptions);\n    const remove = () => {\n      element.removeEventListener(type, handler, eventOptions);\n      listeners.delete(remove);\n    };\n    listeners.add(remove);\n    return remove;\n  }\n  clean() {\n    this._listeners.forEach(remove => remove());\n    this._listeners.clear();\n  }\n}\n\nclass TimeoutStore {\n  constructor() {\n    _defineProperty(this, \"_timeouts\", new Map());\n  }\n  add(key, callback, ms = 140, ...args) {\n    this.remove(key);\n    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));\n  }\n  remove(key) {\n    const timeout = this._timeouts.get(key);\n    if (timeout) window.clearTimeout(timeout);\n  }\n  clean() {\n    this._timeouts.forEach(timeout => void window.clearTimeout(timeout));\n    this._timeouts.clear();\n  }\n}\n\nclass Controller {\n  constructor(handlers) {\n    _defineProperty(this, \"gestures\", new Set());\n    _defineProperty(this, \"_targetEventStore\", new EventStore(this));\n    _defineProperty(this, \"gestureEventStores\", {});\n    _defineProperty(this, \"gestureTimeoutStores\", {});\n    _defineProperty(this, \"handlers\", {});\n    _defineProperty(this, \"config\", {});\n    _defineProperty(this, \"pointerIds\", new Set());\n    _defineProperty(this, \"touchIds\", new Set());\n    _defineProperty(this, \"state\", {\n      shared: {\n        shiftKey: false,\n        metaKey: false,\n        ctrlKey: false,\n        altKey: false\n      }\n    });\n    resolveGestures(this, handlers);\n  }\n  setEventIds(event) {\n    if (isTouch(event)) {\n      this.touchIds = new Set(touchIds(event));\n      return this.touchIds;\n    } else if ('pointerId' in event) {\n      if (event.type === 'pointerup' || event.type === 'pointercancel') this.pointerIds.delete(event.pointerId);else if (event.type === 'pointerdown') this.pointerIds.add(event.pointerId);\n      return this.pointerIds;\n    }\n  }\n  applyHandlers(handlers, nativeHandlers) {\n    this.handlers = handlers;\n    this.nativeHandlers = nativeHandlers;\n  }\n  applyConfig(config, gestureKey) {\n    this.config = parse(config, gestureKey, this.config);\n  }\n  clean() {\n    this._targetEventStore.clean();\n    for (const key of this.gestures) {\n      this.gestureEventStores[key].clean();\n      this.gestureTimeoutStores[key].clean();\n    }\n  }\n  effect() {\n    if (this.config.shared.target) this.bind();\n    return () => this._targetEventStore.clean();\n  }\n  bind(...args) {\n    const sharedConfig = this.config.shared;\n    const props = {};\n    let target;\n    if (sharedConfig.target) {\n      target = sharedConfig.target();\n      if (!target) return;\n    }\n    if (sharedConfig.enabled) {\n      for (const gestureKey of this.gestures) {\n        const gestureConfig = this.config[gestureKey];\n        const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);\n        if (gestureConfig.enabled) {\n          const Engine = EngineMap.get(gestureKey);\n          new Engine(this, args, gestureKey).bind(bindFunction);\n        }\n      }\n      const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);\n      for (const eventKey in this.nativeHandlers) {\n        nativeBindFunction(eventKey, '', event => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {\n          event,\n          args\n        })), undefined, true);\n      }\n    }\n    for (const handlerProp in props) {\n      props[handlerProp] = chain(...props[handlerProp]);\n    }\n    if (!target) return props;\n    for (const handlerProp in props) {\n      const {\n        device,\n        capture,\n        passive\n      } = parseProp(handlerProp);\n      this._targetEventStore.add(target, device, '', props[handlerProp], {\n        capture,\n        passive\n      });\n    }\n  }\n}\nfunction setupGesture(ctrl, gestureKey) {\n  ctrl.gestures.add(gestureKey);\n  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);\n  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();\n}\nfunction resolveGestures(ctrl, internalHandlers) {\n  if (internalHandlers.drag) setupGesture(ctrl, 'drag');\n  if (internalHandlers.wheel) setupGesture(ctrl, 'wheel');\n  if (internalHandlers.scroll) setupGesture(ctrl, 'scroll');\n  if (internalHandlers.move) setupGesture(ctrl, 'move');\n  if (internalHandlers.pinch) setupGesture(ctrl, 'pinch');\n  if (internalHandlers.hover) setupGesture(ctrl, 'hover');\n}\nconst bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {\n  var _options$capture, _options$passive;\n  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;\n  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;\n  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);\n  if (withPassiveOption && passive) handlerProp += 'Passive';\n  props[handlerProp] = props[handlerProp] || [];\n  props[handlerProp].push(handler);\n};\n\nconst RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;\nfunction sortHandlers(_handlers) {\n  const native = {};\n  const handlers = {};\n  const actions = new Set();\n  for (let key in _handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch);\n      handlers[key] = _handlers[key];\n    } else {\n      native[key] = _handlers[key];\n    }\n  }\n  return [handlers, native, actions];\n}\nfunction registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {\n  if (!actions.has(handlerKey)) return;\n  if (!EngineMap.has(key)) {\n    if (process.env.NODE_ENV === 'development') {\n      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \\`${key}\\` gesture but isn't properly configured.\\n\\nPlease add \\`${key}Action\\` when creating your handler.`);\n    }\n    return;\n  }\n  const startKey = handlerKey + 'Start';\n  const endKey = handlerKey + 'End';\n  const fn = state => {\n    let memo = undefined;\n    if (state.first && startKey in handlers) handlers[startKey](state);\n    if (handlerKey in handlers) memo = handlers[handlerKey](state);\n    if (state.last && endKey in handlers) handlers[endKey](state);\n    return memo;\n  };\n  internalHandlers[key] = fn;\n  config[key] = config[key] || {};\n}\nfunction parseMergedHandlers(mergedHandlers, mergedConfig) {\n  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);\n  const internalHandlers = {};\n  registerGesture(actions, handlers, 'onDrag', 'drag', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onWheel', 'wheel', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onScroll', 'scroll', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onPinch', 'pinch', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onMove', 'move', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onHover', 'hover', internalHandlers, mergedConfig);\n  return {\n    handlers: internalHandlers,\n    config: mergedConfig,\n    nativeHandlers\n  };\n}\n\nexport { Controller, parseMergedHandlers };\n","import { registerAction, dragAction, pinchAction, wheelAction, scrollAction, moveAction, hoverAction } from '@use-gesture/core/actions';\nexport * from '@use-gesture/core/actions';\nimport React from 'react';\nimport { Controller, parseMergedHandlers } from '@use-gesture/core';\nexport * from '@use-gesture/core/utils';\nexport * from '@use-gesture/core/types';\n\nfunction useRecognizers(handlers, config = {}, gestureKey, nativeHandlers) {\n  const ctrl = React.useMemo(() => new Controller(handlers), []);\n  ctrl.applyHandlers(handlers, nativeHandlers);\n  ctrl.applyConfig(config, gestureKey);\n  React.useEffect(ctrl.effect.bind(ctrl));\n  React.useEffect(() => {\n    return ctrl.clean.bind(ctrl);\n  }, []);\n  if (config.target === undefined) {\n    return ctrl.bind.bind(ctrl);\n  }\n  return undefined;\n}\n\nfunction useDrag(handler, config) {\n  registerAction(dragAction);\n  return useRecognizers({\n    drag: handler\n  }, config || {}, 'drag');\n}\n\nfunction usePinch(handler, config) {\n  registerAction(pinchAction);\n  return useRecognizers({\n    pinch: handler\n  }, config || {}, 'pinch');\n}\n\nfunction useWheel(handler, config) {\n  registerAction(wheelAction);\n  return useRecognizers({\n    wheel: handler\n  }, config || {}, 'wheel');\n}\n\nfunction useScroll(handler, config) {\n  registerAction(scrollAction);\n  return useRecognizers({\n    scroll: handler\n  }, config || {}, 'scroll');\n}\n\nfunction useMove(handler, config) {\n  registerAction(moveAction);\n  return useRecognizers({\n    move: handler\n  }, config || {}, 'move');\n}\n\nfunction useHover(handler, config) {\n  registerAction(hoverAction);\n  return useRecognizers({\n    hover: handler\n  }, config || {}, 'hover');\n}\n\nfunction createUseGesture(actions) {\n  actions.forEach(registerAction);\n  return function useGesture(_handlers, _config) {\n    const {\n      handlers,\n      nativeHandlers,\n      config\n    } = parseMergedHandlers(_handlers, _config || {});\n    return useRecognizers(handlers, config, undefined, nativeHandlers);\n  };\n}\n\nfunction useGesture(handlers, config) {\n  const hook = createUseGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction]);\n  return hook(handlers, config || {});\n}\n\nexport { createUseGesture, useDrag, useGesture, useHover, useMove, usePinch, useScroll, useWheel };\n","/*\n * Copyright (C) 2021-present Rong \"Mantle\" Bao\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see https://www.gnu.org/licenses/ .\n */\n\nimport { PageProps, graphql } from \"gatsby\"\nimport { throttle } from \"lodash\"\nimport React, { useEffect } from \"react\"\n\nimport { useDrag } from \"@use-gesture/react\"\n\nimport Box from \"@mui/material/Box\"\n\nimport { PageID } from \"../PageID\"\nimport { flushed, queryPath } from \"../common\"\nimport { BlocksGrid, CommonHead, GameControlBackdrop } from \"../components\"\nimport { customizationFacade } from \"../customization\"\nimport { GameViewModel } from \"../viewmodel\"\n\nconst App = ({ data }: PageProps<Queries.GamePageQuery>) => {\n  const routes = data.site?.siteMetadata?.navRoutes\n  const homePagePath = queryPath(routes, PageID.PAGE_HOME)\n\n  const viewModel = new GameViewModel()\n\n  const onKeyDownThrottled = throttle(\n    flushed(viewModel.onKeyDown.bind(viewModel)),\n    50\n  )\n  const onTapThrottled = throttle(flushed(viewModel.onTap.bind(viewModel)), 50)\n  const onSwipeThrottled = throttle(\n    flushed(viewModel.onSwipe.bind(viewModel)),\n    50\n  )\n\n  useEffect(() => {\n    window.addEventListener(\"keydown\", onKeyDownThrottled)\n    viewModel.init()\n    return () => {\n      window.removeEventListener(\"keydown\", onKeyDownThrottled)\n      viewModel.reset(true)\n    }\n  }, [])\n\n  const gestureBind = useDrag(\n    ({ swipe, tap, elapsedTime }) => {\n      if (tap) {\n        onTapThrottled(elapsedTime)\n      } else {\n        onSwipeThrottled(swipe)\n      }\n    },\n    {\n      filterTaps: true,\n      swipe: {\n        distance: [\n          customizationFacade.settings.swipeDeltaX,\n          customizationFacade.settings.swipeDeltaY,\n        ],\n        duration: customizationFacade.settings.swipeThreshold,\n      },\n    }\n  )\n\n  return (\n    <Box\n      sx={{\n        /* display-related props */\n        display: \"grid\",\n        gridTemplateRows: \"1fr 90% 1fr\",\n\n        /* layouts: width, height, margin, padding, etc.*/\n        position: \"relative\",\n        height: \"100%\",\n        minHeight: \"0px\",\n        width: \"100%\",\n        minWidth: \"0px\",\n        boxSizing: \"border-box\",\n        flex: \"1 1 auto\" /* For common layout */,\n\n        /* element-specific props */\n      }}\n    >\n      <GameControlBackdrop\n        homePagePath={homePagePath}\n        startGameHandler={viewModel.requestStartGame.bind(viewModel)}\n        switchPauseGameHandler={viewModel.switchPauseGame.bind(viewModel)}\n      />\n      <Box\n        sx={{\n          gridRow: 2,\n          position: \"relative\",\n        }}\n        {...gestureBind()}\n      >\n        <BlocksGrid />\n      </Box>\n    </Box>\n  )\n}\n\nexport default App\n\nexport const Head = CommonHead\n\nexport const query = graphql`\n  query GamePage($language: String!) {\n    site {\n      siteMetadata {\n        navRoutes {\n          id\n          path\n        }\n      }\n    }\n\n    locales: allLocale(\n      filter: { ns: { in: [\"game\"] }, language: { eq: $language } }\n    ) {\n      edges {\n        node {\n          ns\n          data\n          language\n        }\n      }\n    }\n  }\n`\n"],"names":["isObject","now","toNumber","nativeMax","Math","max","nativeMin","min","module","exports","func","wait","options","lastArgs","lastThis","maxWait","result","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","TypeError","invokeFunc","time","args","thisArg","undefined","apply","shouldInvoke","timeSinceLastCall","timerExpired","trailingEdge","setTimeout","timeWaiting","remainingWait","debounced","isInvoking","arguments","this","leadingEdge","clearTimeout","cancel","flush","root","Date","debounce","PageID","V","toVector","v","fallback","Array","isArray","add","v1","v2","sub","addTo","subTo","rubberband","distance","dimension","constant","abs","Infinity","pow","rubberbandIfOutOfBounds","position","clamp","_toPropertyKey","arg","key","input","hint","prim","Symbol","toPrimitive","res","call","String","Number","_toPrimitive","_defineProperty","obj","value","Object","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","_objectSpread2","target","i","length","source","forEach","getOwnPropertyDescriptors","defineProperties","EVENT_TYPE_MAP","pointer","start","change","end","mouse","touch","gesture","capitalize","string","toUpperCase","slice","actionsWithoutCaptureSupported","toHandlerProp","device","action","capture","deviceProps","actionKey","includes","hasCapture","pointerCaptureEvents","parseProp","prop","eventKey","substring","toLowerCase","passive","indexOf","replace","captureKey","isTouch","event","getPointerType","pointerType","getValueEvent","type","changedTouches","targetTouches","getTouchList","touchIds","from","touches","e","_event$currentTarget","_event$currentTarget$","currentTarget","contains","getCurrentTargetTouchList","map","identifier","pointerId","valueEvent","pointerValues","clientX","clientY","noop","chain","fns","fn","assignDefault","assign","Engine","constructor","ctrl","state","computeValues","computeInitial","init","reset","shared","eventStore","gestureEventStores","timeoutStore","gestureTimeoutStores","config","sharedConfig","handler","handlers","ingKey","_active","active","_blocked","_force","_step","intentional","_movement","_distance","_direction","_delta","_bounds","axis","memo","elapsedTime","timeDelta","direction","overflow","_movementBound","velocity","movement","delta","timeStamp","lastOffset","offset","startTime","values","_values","transform","_initial","initial","compute","dt","preventDefault","cancelable","pointerIds","size","locked","document","pointerLockElement","payload","buttons","shiftKey","altKey","metaKey","ctrlKey","getEventDetails","down","pressed","_absoluteDelta","axisIntent","_m0","_m1","t0","t1","threshold","hasCustomTransform","sign","v0","restrictToAxis","previousOffset","gestureIsActive","first","last","bounds","setup","computeOffset","ox","oy","x0","x1","y0","y1","Vx","Vy","Rx","Ry","X0","X1","Y0","Y1","computeRubberband","computeMovement","absoluteDelta","emit","clean","triggerAllEvents","aliasKey","CoordinatesEngine","super","axisThreshold","dx","dy","absDx","absDy","selectAxis","lockDirection","identity","commonConfigResolver","enabled","eventOptions","_k","coordinatesConfigResolver","_v","current","HTMLElement","left","right","top","bottom","KEYS_DELTA_MAP","ArrowRight","displacement","factor","ArrowLeft","ArrowUp","ArrowDown","isBrowser","window","createElement","isTouchScreen","navigator","maxTouchPoints","SUPPORT","GestureEvent","supportsGestureEvents","touchscreen","pointerLock","DEFAULT_DRAG_AXIS_THRESHOLD","pen","dragConfigResolver","lock","preventScrollAxis","preventScroll","preventScrollDelay","pointerCapture","pointerButtons","filterTaps","tapsThreshold","swipe","duration","delay","keyboardDisplacement","scaleBounds","angleBounds","_scaleBounds","D","_angleBounds","A","modifierKey","pinchOnWheel","mouseOnly","Map","ConfigResolverMap","engine","_pointerId","_pointerActive","_keyboardActive","_preventScroll","_delayed","tap","canceled","bind","boundRect","getBoundingClientRect","targetRect","setActive","pointerClean","pointerDown","ctrlIds","setEventIds","setPointerCapture","setupPointer","setupScrollPrevention","setupDelayTrigger","startPointerDrag","pointerMove","id","movementX","movementY","remove","pointerUp","hasPointerCapture","releasePointerCapture","_unused","_dx","_dy","_mx","_my","svx","svy","sx","sy","sdt","_vx","_vy","pointerClick","detail","stopPropagation","requestPointerLock","exitPointerLock","persist","persistEvent","keyDown","deltaFn","keyUp","bindFunction","resolver","_objectWithoutProperties","excluded","sourceKeys","_objectWithoutPropertiesLoose","sourceSymbolKeys","prototype","propertyIsEnumerable","sharedConfigResolver","_excluded","resolveWith","resolvers","entries","EventStore","gestureKey","Set","_ctrl","_gestureKey","element","listeners","_listeners","toDomEventType","addEventListener","removeEventListener","delete","clear","TimeoutStore","callback","ms","_timeouts","set","timeout","get","Controller","internalHandlers","drag","setupGesture","wheel","scroll","move","pinch","hover","resolveGestures","applyHandlers","nativeHandlers","applyConfig","newConfig","_config","_ref","rest","parse","_targetEventStore","gestures","effect","props","gestureConfig","bindToProps","nativeBindFunction","handlerProp","withPassiveOption","isNative","_options$capture","_options$passive","useRecognizers","useDrag","_data$site","_data$site$siteMetada","data","routes","site","siteMetadata","navRoutes","homePagePath","queryPath","PAGE_HOME","viewModel","GameViewModel","onKeyDownThrottled","_throttle","flushed","onKeyDown","onTapThrottled","onTap","onSwipeThrottled","onSwipe","useEffect","gestureBind","_ref2","customizationFacade","settings","swipeDeltaX","swipeDeltaY","swipeThreshold","React","Box","display","gridTemplateRows","height","minHeight","width","minWidth","boxSizing","flex","GameControlBackdrop","startGameHandler","requestStartGame","switchPauseGameHandler","switchPauseGame","gridRow","BlocksGrid","Head","CommonHead"],"sourceRoot":""}